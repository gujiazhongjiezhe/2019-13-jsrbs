<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <script>
        /* 
        ES6:
        1、let和const
            1、let和const没有变量提升。var有变量提升
            2、let和const不能重复声明，var可以
            3、let可以解决暂时性死区
            4、let可以形成块级作用域(大括号结合)
            5、var在全局作用域下声明变量会给window增加价键值对，let不会
            6、const定义的常量必须赋值
        2、箭头函数
            1、箭头函数没有this
            2、没有arguments
            3、如果在箭头函数里使用this，那他就会往上一级作用域查找this
            4、如果只有一个形参，可以去掉小括号
            5、如果只有return一行代码，可以省略return和大括号
            6、如果return的是一个对象，你要是省略的话，就给对象加小括号
            7、给函数的形参赋默认值(普通函数和箭头函数都可以)

        3、...运算符
            1、收缩运算符(一般用在函数的形参里)
            2、展开运算符(一般用在函数的实参)
            3、拓展运算符

        4、class自定义类
        5、模板字符串(``)
        */
        //    let m;
        //    const y;
        // =====================================================
        // let fn = () => {
        //     console.log(this)
        // }
        // fn()
        // let obj = {
        //     name:3,
        //     fn:function(){
        //         // this->obj
        //         return ()=>{
        //             console.log(this)
        //         }
        //     }
        // }
        // obj.fn()()
        // let fn = (w)=>{
        //     return {name:3}
        // }
        // let fn1 = w=>({name:3})
        // console.log(fn1())
    // =====================================
    // ...运算符
    // function fn(...g){
    //     console.log(g)
    // }
    // fn(...[12,34,46,67,78,132,32,34])
    // let ary = [12,23,45,66];
    // // let n = ary[0]
    // // let m  =[]
    // // 前提是等号的左边和右边结构的一样
    // let [m,...a] = ary;
    // console.log(m,a) // 12 , [23, 45, 66]

    // // 我想拿到数组的第一项和最后一项
    // // let [x,,,s] = ary;
    // console.log(x,s)
        // let ary = [12,234,45,[23,435]];
        // console.log(ary[3][1]) // 435
        // let [m,,,[,x]] = ary
        // console.log(m,x) // 12, 435

    // 普通对象的解构赋值
    // let obj = {
    //     name:2,
    //     age:3
    // }
    // let obj1 = {...obj}
    // console.log(obj1) // 克隆obj
    // 在左边的对象里定义变量名，如果这个变量名在右边的对象里有对应的属性名，那就把对应的属性值赋值给左边的变量名
    // 如果右边没有这个属性名就是undefined
    // 还可以给左边的变量赋默认值
    // let {name,age,we = 9} = obj;
    // console.log(name, age,we);
    // let ary = [1,2,3];
    // let  [m, , , r = 6] = ary
    // console.log(m,r)
    
    // let obj = {
    //     name:3,
    //     age:4
    // }

    // // name:haha  
    // // 创建一个haha变量名，把name对应的值赋值给他
    // let {
    //     name:haha
    // } = obj
    // console.log(haha)

    // let obj = {
    //     name:'erYa',
    //     age:18,
    //     friends:['xioaHua', 'gouDan']
    // }
    // let {friends:[,s]} = obj
    // console.log(s) // 'gouDan'
    // =====================================
    // class自定义类

    // function Fn(){
    //     this.s = 5;
    // }
    // Fn.prototype.getX = function(){
    // }
    // Fn()
    // new Fn

    // class Fn {
    //     // 这里边放的是实例的私有属性
    //     constructor (n,m){
    //         this.s = n // 给实例增加私有属性
    //     }
    //     // 直接在外边写就是给实例添加公有属性(如果赋的值不是一个方法，那就是给实例增加私有属性)
    //     getX(){
    //         console.log(111)
    //     }
    //     e = function (params) {
    //             console.log(444)
    //     }
    //     r = 4 // 用等号的形式就是给实例增加私有属性
    //     w = {g:333}
    //     static m = 10 // 把Fn当做对象，增加键值对
    // }
    // Fn.prototype.getY = function(){console.log(222)}
    // let f = new Fn(3);
    // // Fn() 报错
    // console.log(f)
    // console.log(Fn.prototype)
    // console.dir(Fn);
    
//  let ss = 25;
//  let str = '<li>'+ss+'</li>';
            // '<li><span>'+ss+'</span><span>'+ss+'</span></li>'
    // let str = `<li><span>${ss}</span><span>${ss}</span></li>`
 console.log(str)
    </script>
</body>

</html>