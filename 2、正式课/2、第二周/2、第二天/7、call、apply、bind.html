<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <div id="box">1111</div>
    <script>
        //  "use strict"  // 使用严格模式
      /* 
      每一个函数都是Function的实例，所以每一个函数都可以调取Function原型上的方法，
      call、apply、bind
      他们三个都可以改变函数里的this指向
      */  
     
    //   function fn(n,m){
    //       console.log(this, n,m)

    //   }
    //   let obj = {
    //       name:3
    //   }
    //   fn(12,13)
    // 实现把函数里的this改为obj
    //   obj.fn = fn;
    //   obj.fn();
    //   delete obj.fn;


// 一、  call方法
    // fn.call(2, 12,13)
    /* 
    1、fn通过__proto__属性找到当前所属类的原型（Function的原型）上的call方法
    2、让call方法执行，并且给call传递实参
    3、在call方法执行的同时，也让fn执行，并且把fn的this指向了第一个参数
    */

   /* 
    1、在严格模式下，如果call不传参或者传undefined，那fn的this就是undefined，如果传null，那fn的this就是null

    2、在非严格模式下，如果call不传参或者传undefined或者传null，那fn的this都是window
    3、call的第一个参数是fn的this指向，从第二个开始，就都是fn的正常参数了
   */
    // 
    // this不允许出现在等号的左边(不能给this直接赋值)【this不能直接改】
    //   function fn(){
    //     this = 12;
    //   }
    //   fn()

// 二、apply:他和call方法一样，只不过第二个参数必须是数组或者类数组
        // function fn(n,m){
        //     console.log(this, n, m)
        // }
        // fn.apply(1, [20,30])

// 三、bind:这个方法也是改变this指向的，但他会提前改变实例函数的this指向，并不会让实例函数执行,他的返回值是改变this之后的新函数
            let box = document.getElementById('box');
            let fn = function(){
                console.log(this)
            };
            let obj = {}
            box.onclick  = fn.bind(obj)

            fn = fn.bind(obj)
            fn()
            // let ww = fn.bind(obj)
            console.log(ww === fn) // false




        //   let num = 1;
        //   let ss = Number(1);
        //   console.log(num.toFixed(2))
        //   console.log(ss.toFixed(2))
    </script>
</body>
</html>