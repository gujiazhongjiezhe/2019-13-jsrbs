<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <script>
        // let reg = /^1[3-9]\d{9}$/
        // let str = '15532898888';
        // console.log(reg.test(str))

        /* 
        1、exec
            返回值：是一个数组，捕获不到是null
                    第一个是全局捕获
                    以后的是所有的的分组捕获
                    input是原字符串
                    index第一次捕获的索引

        2、replace(//, )


        3、match
            返回值：
            如果有g，返回的值捕获的每一项内容，但是不能分组捕获
        */
        // let fn = () => {
        //     // console.log(arguments) // [1,2,3,4,5]
        //     // console.log(this)
        // }
        // let obj = {fn:fn}

        // obj.fn(1, 2, 3, 4, 5)

        // let str = '111';
        // str.replace(/^$/, function(){
        //     // 匹配几次回调函数就执行几次
        //     // 当回到函数执行时，把捕获的内容当做函数的实参传递给回调函数
        //     // 函数的返回值(return 后面的东西)会替换捕获到的内容
        // })

        // let str = '{33}ww{33}ww';
        // let reg = /\{(\d{2})\}/g
        // console.log(str.match(reg))
        /* 
        邮箱匹配
        let reg = /^[a-z0-9A-Z-_]+@[a-z0-9]+(\.[a-z]+){1,2}$/
        2222@qq.com.cn
        */

        /* 
        1、clientHeight clientWidth  clientLeft  clientTop
        2、offsetHeight offsetWidth  offsetParent  offsetTop offsetLeft
        3、scrollHeight scrollWidth  scrollLeft  scrollTop
        */

       /* 
       this出现的情况
       1、箭头函数没有this
       2、自执行函数里的this是window
       3、函数执行的时候，函数里的this要看执行函数前有没有点，如果有点，点前面是谁，this就是谁，如果没有点就是window
       4、给元素绑定事件行为方法，方法里的this指向当前元素本身，
       5、构造函数里的this是当前实例
       6、原型上公有方法里面的this一般是当前的实例
       7、回到函数里的this一般是window
       8、全局作用域里的this是window
       */

       /* 
       原型的三句话
       1、每一个函数都天生自带一个prototype属性，指向一个对象，里面存储的是其实例的公有属性，(原型)
       2、每一个原型自带一个constructor属性，其属性值指向他的类
       3、每一个对象自带一个__proto__，其属性值指向当前所属类的原型
       */

       /* 
       作用域链，原型链
       作用域链：
       1、函数执行形成私有作用域，使用一个变量的时候，先看自己有没有，如果自己没有，就往上一级作用域查找，如果还没有，就往上一级的上一级找，直到找到全局，如果还没有就报错
       上一级作用域的定义：在函数创建的时候就已经定义好了，在哪创建的，那他的上一级作用域就是哪，跟在哪执行的没有关系
       原型链：
       1、查找实例的属性，先看自己私有的有没有，如果没有，通过__proto__往当前所属类的原型上去找,如果还没有，就找原型的原型，直到找到Object的原型为止，如果还没有就是undefined
       */

       
    </script>
</body>

</html>